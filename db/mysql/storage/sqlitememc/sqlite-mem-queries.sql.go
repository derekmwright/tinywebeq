// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: sqlite-mem-queries.sql

package sqlitememc

import (
	"context"
)

const itemByItemID = `-- name: ItemByItemID :one
SELECT gob FROM item WHERE item_id = ? AND expiration > ?
`

type ItemByItemIDParams struct {
	ItemID     int64
	Expiration int64
}

func (q *Queries) ItemByItemID(ctx context.Context, arg ItemByItemIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, itemByItemID, arg.ItemID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const itemCreate = `-- name: ItemCreate :exec
CREATE TABLE IF NOT EXISTS item (item_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) ItemCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, itemCreate)
	return err
}

const itemQuestByItemID = `-- name: ItemQuestByItemID :one
SELECT gob FROM item_quest WHERE item_id = ? AND expiration > ?
`

type ItemQuestByItemIDParams struct {
	ItemID     int64
	Expiration int64
}

func (q *Queries) ItemQuestByItemID(ctx context.Context, arg ItemQuestByItemIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, itemQuestByItemID, arg.ItemID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const itemQuestCreate = `-- name: ItemQuestCreate :exec
CREATE TABLE IF NOT EXISTS item_quest (item_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) ItemQuestCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, itemQuestCreate)
	return err
}

const itemQuestReplace = `-- name: ItemQuestReplace :exec
REPLACE INTO item_quest (item_id, gob, expiration) VALUES (?, ?, ?)
`

type ItemQuestReplaceParams struct {
	ItemID     int64
	Gob        string
	Expiration int64
}

func (q *Queries) ItemQuestReplace(ctx context.Context, arg ItemQuestReplaceParams) error {
	_, err := q.db.ExecContext(ctx, itemQuestReplace, arg.ItemID, arg.Gob, arg.Expiration)
	return err
}

const itemQuestTruncate = `-- name: ItemQuestTruncate :exec
DELETE FROM item_quest WHERE expiration < ?
`

func (q *Queries) ItemQuestTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, itemQuestTruncate, expiration)
	return err
}

const itemRecipeByItemID = `-- name: ItemRecipeByItemID :one
SELECT gob FROM item_recipe WHERE item_id = ? AND expiration > ?
`

type ItemRecipeByItemIDParams struct {
	ItemID     int64
	Expiration int64
}

func (q *Queries) ItemRecipeByItemID(ctx context.Context, arg ItemRecipeByItemIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, itemRecipeByItemID, arg.ItemID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const itemRecipeCreate = `-- name: ItemRecipeCreate :exec
CREATE TABLE IF NOT EXISTS item_recipe (item_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) ItemRecipeCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, itemRecipeCreate)
	return err
}

const itemRecipeReplace = `-- name: ItemRecipeReplace :exec
REPLACE INTO item_recipe (item_id, gob, expiration) VALUES (?, ?, ?)
`

type ItemRecipeReplaceParams struct {
	ItemID     int64
	Gob        string
	Expiration int64
}

func (q *Queries) ItemRecipeReplace(ctx context.Context, arg ItemRecipeReplaceParams) error {
	_, err := q.db.ExecContext(ctx, itemRecipeReplace, arg.ItemID, arg.Gob, arg.Expiration)
	return err
}

const itemRecipeTruncate = `-- name: ItemRecipeTruncate :exec
DELETE FROM item_recipe WHERE expiration < ?
`

func (q *Queries) ItemRecipeTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, itemRecipeTruncate, expiration)
	return err
}

const itemReplace = `-- name: ItemReplace :exec
REPLACE INTO item (item_id, gob, expiration) VALUES (?, ?, ?)
`

type ItemReplaceParams struct {
	ItemID     int64
	Gob        string
	Expiration int64
}

func (q *Queries) ItemReplace(ctx context.Context, arg ItemReplaceParams) error {
	_, err := q.db.ExecContext(ctx, itemReplace, arg.ItemID, arg.Gob, arg.Expiration)
	return err
}

const itemSearchByID = `-- name: ItemSearchByID :one
SELECT id, name, level FROM item_search WHERE id = ?
`

func (q *Queries) ItemSearchByID(ctx context.Context, id int64) (ItemSearch, error) {
	row := q.db.QueryRowContext(ctx, itemSearchByID, id)
	var i ItemSearch
	err := row.Scan(&i.ID, &i.Name, &i.Level)
	return i, err
}

const itemSearchByName = `-- name: ItemSearchByName :many
SELECT id, name, level FROM item_search WHERE name LIKE ? ORDER BY level DESC LIMIT 10
`

func (q *Queries) ItemSearchByName(ctx context.Context, name string) ([]ItemSearch, error) {
	rows, err := q.db.QueryContext(ctx, itemSearchByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemSearch
	for rows.Next() {
		var i ItemSearch
		if err := rows.Scan(&i.ID, &i.Name, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const itemSearchCreate = `-- name: ItemSearchCreate :exec
CREATE TABLE IF NOT EXISTS item_search (id INTEGER PRIMARY KEY NOT NULL, name TEXT COLLATE NOCASE NOT NULL, level INTEGER NOT NULL)
`

func (q *Queries) ItemSearchCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, itemSearchCreate)
	return err
}

const itemSearchInsert = `-- name: ItemSearchInsert :exec
INSERT INTO item_search (id, name, level) VALUES (?, ?, ?)
`

type ItemSearchInsertParams struct {
	ID    int64
	Name  string
	Level int64
}

func (q *Queries) ItemSearchInsert(ctx context.Context, arg ItemSearchInsertParams) error {
	_, err := q.db.ExecContext(ctx, itemSearchInsert, arg.ID, arg.Name, arg.Level)
	return err
}

const itemTruncate = `-- name: ItemTruncate :exec
DELETE FROM item WHERE expiration < ?
`

func (q *Queries) ItemTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, itemTruncate, expiration)
	return err
}

const npcByNpcID = `-- name: NpcByNpcID :one
SELECT gob FROM npc WHERE npc_id = ? AND expiration > ?
`

type NpcByNpcIDParams struct {
	NpcID      int64
	Expiration int64
}

func (q *Queries) NpcByNpcID(ctx context.Context, arg NpcByNpcIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, npcByNpcID, arg.NpcID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const npcCreate = `-- name: NpcCreate :exec
CREATE TABLE IF NOT EXISTS npc (npc_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) NpcCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, npcCreate)
	return err
}

const npcFactionByFactionID = `-- name: NpcFactionByFactionID :one
SELECT gob FROM npc_faction WHERE faction_id = ? AND expiration > ?
`

type NpcFactionByFactionIDParams struct {
	FactionID  int64
	Expiration int64
}

func (q *Queries) NpcFactionByFactionID(ctx context.Context, arg NpcFactionByFactionIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, npcFactionByFactionID, arg.FactionID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const npcFactionCreate = `-- name: NpcFactionCreate :exec
CREATE TABLE IF NOT EXISTS npc_faction (faction_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) NpcFactionCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, npcFactionCreate)
	return err
}

const npcFactionReplace = `-- name: NpcFactionReplace :exec
REPLACE INTO npc_faction (faction_id, gob, expiration) VALUES (?, ?, ?)
`

type NpcFactionReplaceParams struct {
	FactionID  int64
	Gob        string
	Expiration int64
}

func (q *Queries) NpcFactionReplace(ctx context.Context, arg NpcFactionReplaceParams) error {
	_, err := q.db.ExecContext(ctx, npcFactionReplace, arg.FactionID, arg.Gob, arg.Expiration)
	return err
}

const npcFactionTruncate = `-- name: NpcFactionTruncate :exec
DELETE FROM npc_faction WHERE expiration < ?
`

func (q *Queries) NpcFactionTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, npcFactionTruncate, expiration)
	return err
}

const npcLootByLootTableID = `-- name: NpcLootByLootTableID :one
SELECT gob FROM npc_loot WHERE loot_table_id = ? AND expiration > ?
`

type NpcLootByLootTableIDParams struct {
	LootTableID int64
	Expiration  int64
}

func (q *Queries) NpcLootByLootTableID(ctx context.Context, arg NpcLootByLootTableIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, npcLootByLootTableID, arg.LootTableID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const npcLootCreate = `-- name: NpcLootCreate :exec
CREATE TABLE IF NOT EXISTS npc_loot (loot_table_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) NpcLootCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, npcLootCreate)
	return err
}

const npcLootReplace = `-- name: NpcLootReplace :exec
REPLACE INTO npc_loot (loot_table_id, gob, expiration) VALUES (?, ?, ?)
`

type NpcLootReplaceParams struct {
	LootTableID int64
	Gob         string
	Expiration  int64
}

func (q *Queries) NpcLootReplace(ctx context.Context, arg NpcLootReplaceParams) error {
	_, err := q.db.ExecContext(ctx, npcLootReplace, arg.LootTableID, arg.Gob, arg.Expiration)
	return err
}

const npcLootTruncate = `-- name: NpcLootTruncate :exec
DELETE FROM npc_loot WHERE expiration < ?
`

func (q *Queries) NpcLootTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, npcLootTruncate, expiration)
	return err
}

const npcMerchantByNpcID = `-- name: NpcMerchantByNpcID :one
SELECT gob FROM npc_merchant WHERE npc_id = ? AND expiration > ?
`

type NpcMerchantByNpcIDParams struct {
	NpcID      int64
	Expiration int64
}

func (q *Queries) NpcMerchantByNpcID(ctx context.Context, arg NpcMerchantByNpcIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, npcMerchantByNpcID, arg.NpcID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const npcMerchantCreate = `-- name: NpcMerchantCreate :exec
CREATE TABLE IF NOT EXISTS npc_merchant (npc_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) NpcMerchantCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, npcMerchantCreate)
	return err
}

const npcMerchantReplace = `-- name: NpcMerchantReplace :exec
REPLACE INTO npc_merchant (npc_id, gob, expiration) VALUES (?, ?, ?)
`

type NpcMerchantReplaceParams struct {
	NpcID      int64
	Gob        string
	Expiration int64
}

func (q *Queries) NpcMerchantReplace(ctx context.Context, arg NpcMerchantReplaceParams) error {
	_, err := q.db.ExecContext(ctx, npcMerchantReplace, arg.NpcID, arg.Gob, arg.Expiration)
	return err
}

const npcMerchantTruncate = `-- name: NpcMerchantTruncate :exec
DELETE FROM npc_merchant WHERE expiration < ?
`

func (q *Queries) NpcMerchantTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, npcMerchantTruncate, expiration)
	return err
}

const npcQuestByNpcID = `-- name: NpcQuestByNpcID :one
SELECT gob FROM npc_quest WHERE npc_id = ? AND expiration > ?
`

type NpcQuestByNpcIDParams struct {
	NpcID      int64
	Expiration int64
}

func (q *Queries) NpcQuestByNpcID(ctx context.Context, arg NpcQuestByNpcIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, npcQuestByNpcID, arg.NpcID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const npcQuestCreate = `-- name: NpcQuestCreate :exec
CREATE TABLE IF NOT EXISTS npc_quest (npc_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) NpcQuestCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, npcQuestCreate)
	return err
}

const npcQuestReplace = `-- name: NpcQuestReplace :exec
REPLACE INTO npc_quest (npc_id, gob, expiration) VALUES (?, ?, ?)
`

type NpcQuestReplaceParams struct {
	NpcID      int64
	Gob        string
	Expiration int64
}

func (q *Queries) NpcQuestReplace(ctx context.Context, arg NpcQuestReplaceParams) error {
	_, err := q.db.ExecContext(ctx, npcQuestReplace, arg.NpcID, arg.Gob, arg.Expiration)
	return err
}

const npcQuestTruncate = `-- name: NpcQuestTruncate :exec
DELETE FROM npc_quest WHERE expiration < ?
`

func (q *Queries) NpcQuestTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, npcQuestTruncate, expiration)
	return err
}

const npcReplace = `-- name: NpcReplace :exec
REPLACE INTO npc (npc_id, gob, expiration) VALUES (?, ?, ?)
`

type NpcReplaceParams struct {
	NpcID      int64
	Gob        string
	Expiration int64
}

func (q *Queries) NpcReplace(ctx context.Context, arg NpcReplaceParams) error {
	_, err := q.db.ExecContext(ctx, npcReplace, arg.NpcID, arg.Gob, arg.Expiration)
	return err
}

const npcSearchByID = `-- name: NpcSearchByID :one
SELECT id, name, level FROM npc_search WHERE id = ?
`

func (q *Queries) NpcSearchByID(ctx context.Context, id int64) (NpcSearch, error) {
	row := q.db.QueryRowContext(ctx, npcSearchByID, id)
	var i NpcSearch
	err := row.Scan(&i.ID, &i.Name, &i.Level)
	return i, err
}

const npcSearchByName = `-- name: NpcSearchByName :many
SELECT id, name, level FROM npc_search WHERE name LIKE ? ORDER BY level DESC LIMIT 10
`

func (q *Queries) NpcSearchByName(ctx context.Context, name string) ([]NpcSearch, error) {
	rows, err := q.db.QueryContext(ctx, npcSearchByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NpcSearch
	for rows.Next() {
		var i NpcSearch
		if err := rows.Scan(&i.ID, &i.Name, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const npcSearchCreate = `-- name: NpcSearchCreate :exec
CREATE TABLE IF NOT EXISTS npc_search (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL, level INTEGER NOT NULL)
`

func (q *Queries) NpcSearchCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, npcSearchCreate)
	return err
}

const npcSearchInsert = `-- name: NpcSearchInsert :exec
INSERT INTO npc_search (id, name, level) VALUES (?, ?, ?)
`

type NpcSearchInsertParams struct {
	ID    int64
	Name  string
	Level int64
}

func (q *Queries) NpcSearchInsert(ctx context.Context, arg NpcSearchInsertParams) error {
	_, err := q.db.ExecContext(ctx, npcSearchInsert, arg.ID, arg.Name, arg.Level)
	return err
}

const npcSpawnByNpcID = `-- name: NpcSpawnByNpcID :one
SELECT gob FROM npc_spawn WHERE npc_id = ? AND expiration > ?
`

type NpcSpawnByNpcIDParams struct {
	NpcID      int64
	Expiration int64
}

func (q *Queries) NpcSpawnByNpcID(ctx context.Context, arg NpcSpawnByNpcIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, npcSpawnByNpcID, arg.NpcID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const npcSpawnCreate = `-- name: NpcSpawnCreate :exec
CREATE TABLE IF NOT EXISTS npc_spawn (npc_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) NpcSpawnCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, npcSpawnCreate)
	return err
}

const npcSpawnReplace = `-- name: NpcSpawnReplace :exec
REPLACE INTO npc_spawn (npc_id, gob, expiration) VALUES (?, ?, ?)
`

type NpcSpawnReplaceParams struct {
	NpcID      int64
	Gob        string
	Expiration int64
}

func (q *Queries) NpcSpawnReplace(ctx context.Context, arg NpcSpawnReplaceParams) error {
	_, err := q.db.ExecContext(ctx, npcSpawnReplace, arg.NpcID, arg.Gob, arg.Expiration)
	return err
}

const npcSpawnTruncate = `-- name: NpcSpawnTruncate :exec
DELETE FROM npc_spawn WHERE expiration < ?
`

func (q *Queries) NpcSpawnTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, npcSpawnTruncate, expiration)
	return err
}

const npcSpellByNpcSpellsID = `-- name: NpcSpellByNpcSpellsID :one
SELECT gob FROM npc_spell WHERE npc_spells_id = ? AND expiration > ?
`

type NpcSpellByNpcSpellsIDParams struct {
	NpcSpellsID int64
	Expiration  int64
}

func (q *Queries) NpcSpellByNpcSpellsID(ctx context.Context, arg NpcSpellByNpcSpellsIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, npcSpellByNpcSpellsID, arg.NpcSpellsID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const npcSpellCreate = `-- name: NpcSpellCreate :exec
CREATE TABLE IF NOT EXISTS npc_spell (npc_spells_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) NpcSpellCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, npcSpellCreate)
	return err
}

const npcSpellReplace = `-- name: NpcSpellReplace :exec
REPLACE INTO npc_spell (npc_spells_id, gob, expiration) VALUES (?, ?, ?)
`

type NpcSpellReplaceParams struct {
	NpcSpellsID int64
	Gob         string
	Expiration  int64
}

func (q *Queries) NpcSpellReplace(ctx context.Context, arg NpcSpellReplaceParams) error {
	_, err := q.db.ExecContext(ctx, npcSpellReplace, arg.NpcSpellsID, arg.Gob, arg.Expiration)
	return err
}

const npcSpellTruncate = `-- name: NpcSpellTruncate :exec
DELETE FROM npc_spell WHERE expiration < ?
`

func (q *Queries) NpcSpellTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, npcSpellTruncate, expiration)
	return err
}

const npcTruncate = `-- name: NpcTruncate :exec
DELETE FROM npc WHERE expiration < ?
`

func (q *Queries) NpcTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, npcTruncate, expiration)
	return err
}

const playerByCharacterID = `-- name: PlayerByCharacterID :one
SELECT gob FROM player WHERE character_id = ? AND expiration > ?
`

type PlayerByCharacterIDParams struct {
	CharacterID int64
	Expiration  int64
}

func (q *Queries) PlayerByCharacterID(ctx context.Context, arg PlayerByCharacterIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, playerByCharacterID, arg.CharacterID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const playerCreate = `-- name: PlayerCreate :exec
CREATE TABLE IF NOT EXISTS player (character_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) PlayerCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, playerCreate)
	return err
}

const playerReplace = `-- name: PlayerReplace :exec
REPLACE INTO player (character_id, gob, expiration) VALUES (?, ?, ?)
`

type PlayerReplaceParams struct {
	CharacterID int64
	Gob         string
	Expiration  int64
}

func (q *Queries) PlayerReplace(ctx context.Context, arg PlayerReplaceParams) error {
	_, err := q.db.ExecContext(ctx, playerReplace, arg.CharacterID, arg.Gob, arg.Expiration)
	return err
}

const playerTruncate = `-- name: PlayerTruncate :exec
DELETE FROM player WHERE expiration < ?
`

func (q *Queries) PlayerTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, playerTruncate, expiration)
	return err
}

const questByID = `-- name: QuestByID :one
SELECT gob FROM quest WHERE quest_id = ? AND expiration > ?
`

type QuestByIDParams struct {
	QuestID    int64
	Expiration int64
}

func (q *Queries) QuestByID(ctx context.Context, arg QuestByIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, questByID, arg.QuestID, arg.Expiration)
	var gob string
	err := row.Scan(&gob)
	return gob, err
}

const questCreate = `-- name: QuestCreate :exec
CREATE TABLE IF NOT EXISTS quest (quest_id INTEGER PRIMARY KEY, gob TEXT NOT NULL, expiration INTEGER NOT NULL)
`

func (q *Queries) QuestCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, questCreate)
	return err
}

const questSearchByName = `-- name: QuestSearchByName :many
SELECT id, name, level FROM quest_search WHERE name LIKE ? ORDER BY level DESC LIMIT 10
`

func (q *Queries) QuestSearchByName(ctx context.Context, name string) ([]QuestSearch, error) {
	rows, err := q.db.QueryContext(ctx, questSearchByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuestSearch
	for rows.Next() {
		var i QuestSearch
		if err := rows.Scan(&i.ID, &i.Name, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const questSearchCreate = `-- name: QuestSearchCreate :exec
CREATE TABLE IF NOT EXISTS quest_search (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL, level INTEGER NOT NULL)
`

func (q *Queries) QuestSearchCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, questSearchCreate)
	return err
}

const questSearchInsert = `-- name: QuestSearchInsert :exec
INSERT INTO quest_search (id, name, level) VALUES (?, ?, ?)
`

type QuestSearchInsertParams struct {
	ID    int64
	Name  string
	Level int64
}

func (q *Queries) QuestSearchInsert(ctx context.Context, arg QuestSearchInsertParams) error {
	_, err := q.db.ExecContext(ctx, questSearchInsert, arg.ID, arg.Name, arg.Level)
	return err
}

const questTruncate = `-- name: QuestTruncate :exec
DELETE FROM quest WHERE expiration < ?
`

func (q *Queries) QuestTruncate(ctx context.Context, expiration int64) error {
	_, err := q.db.ExecContext(ctx, questTruncate, expiration)
	return err
}

const spellByID = `-- name: SpellByID :one
SELECT id, name, level FROM spell WHERE id = ?
`

func (q *Queries) SpellByID(ctx context.Context, id int64) (Spell, error) {
	row := q.db.QueryRowContext(ctx, spellByID, id)
	var i Spell
	err := row.Scan(&i.ID, &i.Name, &i.Level)
	return i, err
}

const spellByName = `-- name: SpellByName :many
SELECT id, name, level FROM spell WHERE name LIKE ? ORDER BY level ASC
`

func (q *Queries) SpellByName(ctx context.Context, name string) ([]Spell, error) {
	rows, err := q.db.QueryContext(ctx, spellByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Spell
	for rows.Next() {
		var i Spell
		if err := rows.Scan(&i.ID, &i.Name, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const spellCreate = `-- name: SpellCreate :exec
CREATE TABLE IF NOT EXISTS spell (id INTEGER PRIMARY KEY NOT NULL, name TEXT COLLATE NOCASE NOT NULL, gob TEXT NOT NULL, level INTEGER NOT NULL)
`

func (q *Queries) SpellCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, spellCreate)
	return err
}

const spellInsert = `-- name: SpellInsert :exec
INSERT INTO spell (id, name, level) VALUES (?, ?, ?)
`

type SpellInsertParams struct {
	ID    int64
	Name  string
	Level int64
}

func (q *Queries) SpellInsert(ctx context.Context, arg SpellInsertParams) error {
	_, err := q.db.ExecContext(ctx, spellInsert, arg.ID, arg.Name, arg.Level)
	return err
}

const spellSearchByName = `-- name: SpellSearchByName :many
SELECT id, name, level FROM spell WHERE name LIKE ? ORDER BY level ASC
`

func (q *Queries) SpellSearchByName(ctx context.Context, name string) ([]Spell, error) {
	rows, err := q.db.QueryContext(ctx, spellSearchByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Spell
	for rows.Next() {
		var i Spell
		if err := rows.Scan(&i.ID, &i.Name, &i.Level); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const zoneByLongName = `-- name: ZoneByLongName :one
SELECT id, short_name, long_name, zone_id_number, expansion, gob FROM zone WHERE long_name = ? AND expansion <= ?
`

type ZoneByLongNameParams struct {
	LongName  string
	Expansion int64
}

func (q *Queries) ZoneByLongName(ctx context.Context, arg ZoneByLongNameParams) (Zone, error) {
	row := q.db.QueryRowContext(ctx, zoneByLongName, arg.LongName, arg.Expansion)
	var i Zone
	err := row.Scan(
		&i.ID,
		&i.ShortName,
		&i.LongName,
		&i.ZoneIDNumber,
		&i.Expansion,
		&i.Gob,
	)
	return i, err
}

const zoneByShortName = `-- name: ZoneByShortName :one
SELECT id, short_name, long_name, zone_id_number, expansion, gob FROM zone WHERE short_name = ? AND expansion <= ?
`

type ZoneByShortNameParams struct {
	ShortName string
	Expansion int64
}

func (q *Queries) ZoneByShortName(ctx context.Context, arg ZoneByShortNameParams) (Zone, error) {
	row := q.db.QueryRowContext(ctx, zoneByShortName, arg.ShortName, arg.Expansion)
	var i Zone
	err := row.Scan(
		&i.ID,
		&i.ShortName,
		&i.LongName,
		&i.ZoneIDNumber,
		&i.Expansion,
		&i.Gob,
	)
	return i, err
}

const zoneByZoneIDNumber = `-- name: ZoneByZoneIDNumber :one
SELECT id, short_name, long_name, zone_id_number, expansion, gob FROM zone WHERE zone_id_number = ? AND expansion <= ?
`

type ZoneByZoneIDNumberParams struct {
	ZoneIDNumber int64
	Expansion    int64
}

func (q *Queries) ZoneByZoneIDNumber(ctx context.Context, arg ZoneByZoneIDNumberParams) (Zone, error) {
	row := q.db.QueryRowContext(ctx, zoneByZoneIDNumber, arg.ZoneIDNumber, arg.Expansion)
	var i Zone
	err := row.Scan(
		&i.ID,
		&i.ShortName,
		&i.LongName,
		&i.ZoneIDNumber,
		&i.Expansion,
		&i.Gob,
	)
	return i, err
}

const zoneCreate = `-- name: ZoneCreate :exec
CREATE TABLE IF NOT EXISTS zone (id INTEGER PRIMARY KEY NOT NULL, short_name TEXT NOT NULL, long_name TEXT NOT NULL, zone_id_number INTEGER NOT NULL, expansion INTEGER NOT NULL)
`

func (q *Queries) ZoneCreate(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, zoneCreate)
	return err
}

const zoneInsert = `-- name: ZoneInsert :exec
INSERT INTO zone (id, short_name, long_name, zone_id_number, expansion) VALUES (?, ?, ?, ?, ?)
`

type ZoneInsertParams struct {
	ID           int64
	ShortName    string
	LongName     string
	ZoneIDNumber int64
	Expansion    int64
}

func (q *Queries) ZoneInsert(ctx context.Context, arg ZoneInsertParams) error {
	_, err := q.db.ExecContext(ctx, zoneInsert,
		arg.ID,
		arg.ShortName,
		arg.LongName,
		arg.ZoneIDNumber,
		arg.Expansion,
	)
	return err
}

const zoneSearchByName = `-- name: ZoneSearchByName :many
SELECT id, short_name, long_name, zone_id_number, expansion, gob FROM zone WHERE (short_name LIKE ? OR long_name LIKE ?) AND expansion <= ? ORDER BY short_name ASC
`

type ZoneSearchByNameParams struct {
	ShortName string
	LongName  string
	Expansion int64
}

func (q *Queries) ZoneSearchByName(ctx context.Context, arg ZoneSearchByNameParams) ([]Zone, error) {
	rows, err := q.db.QueryContext(ctx, zoneSearchByName, arg.ShortName, arg.LongName, arg.Expansion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Zone
	for rows.Next() {
		var i Zone
		if err := rows.Scan(
			&i.ID,
			&i.ShortName,
			&i.LongName,
			&i.ZoneIDNumber,
			&i.Expansion,
			&i.Gob,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
